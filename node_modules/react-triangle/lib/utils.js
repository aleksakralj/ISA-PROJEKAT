'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gridPoints = exports.gridPoint = exports.corners = undefined;

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-mixed-operators,consistent-return */
var THETAS = [0, Math.PI / 3 * 2, Math.PI / 3 * 4];

var range = function range(n) {
  return (0, _from2.default)(Array(n).keys());
};
var product = function product(p, q) {
  var l = [];
  range(p).forEach(function (i) {
    range(q).forEach(function (j) {
      l.push([i, j]);
    });
  });
  return l;
};
var getDiff = function getDiff(direction) {
  if (direction === 'right') return 0;
  if (direction === 'down') return Math.PI / 2;
  if (direction === 'left') return Math.PI;
  if (direction === 'up') return Math.PI / 2 * 3;
};

var corners = exports.corners = function corners(direction, x, y, size) {
  var r = size * Math.sqrt(3) / 3;
  var diff = getDiff(direction);
  return THETAS.map(function (theta) {
    return theta + diff;
  }).map(function (theta) {
    return [x + r * Math.cos(theta), y + r * Math.sin(theta)];
  });
};

var gridPoint = exports.gridPoint = function gridPoint(oDirection, oX, oY, size, gridX, gridY) {
  if (oDirection === 'up') {
    var direction = (gridX + gridY) % 2 === 0 ? 'up' : 'down';
    var diffY = (gridX + gridY) % 2 === 0 ? 0 : size / 2 * Math.sqrt(3) / 3;
    var height = size / 2 * Math.sqrt(3);
    var x = oX + size / 2 * gridX;
    var y = oY - diffY + height * gridY;
    return {
      props: {
        direction: direction,
        x: x,
        y: y,
        size: size
      },
      gridX: gridX,
      gridY: gridY
    };
  } else if (oDirection === 'down') {
    var _direction = (gridX + gridY) % 2 === 0 ? 'down' : 'up';
    var _diffY = (gridX + gridY) % 2 === 0 ? 0 : size / 2 * Math.sqrt(3) / 3;
    var _height = size / 2 * Math.sqrt(3);
    var _x = oX + size / 2 * gridX;
    var _y = oY + _diffY + _height * gridY;
    return {
      props: {
        direction: _direction,
        x: _x,
        y: _y,
        size: size
      },
      gridX: gridX,
      gridY: gridY
    };
  } else if (oDirection === 'left') {
    var _direction2 = (gridX + gridY) % 2 === 0 ? 'left' : 'right';
    var width = size / 2 * Math.sqrt(3);
    var diffX = (gridX + gridY) % 2 === 0 ? 0 : size / 2 * Math.sqrt(3) / 3;
    var _x2 = oX - diffX + width * gridX;
    var _y2 = oY + size / 2 * gridY;
    return {
      props: {
        direction: _direction2,
        x: _x2,
        y: _y2,
        size: size
      },
      gridX: gridX,
      gridY: gridY
    };
  } else if (oDirection === 'right') {
    var _direction3 = (gridX + gridY) % 2 === 0 ? 'right' : 'left';
    var _width = size / 2 * Math.sqrt(3);
    var _diffX = (gridX + gridY) % 2 === 0 ? 0 : size / 2 * Math.sqrt(3) / 3;
    var _x3 = oX + _diffX + _width * gridX;
    var _y3 = oY + size / 2 * gridY;
    return {
      props: {
        direction: _direction3,
        x: _x3,
        y: _y3,
        size: size
      },
      gridX: gridX,
      gridY: gridY
    };
  }
};

var gridPoints = exports.gridPoints = function gridPoints(oDirection, oX, oY, size, gridWidth, gridHeight) {
  return product(gridWidth, gridHeight).map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        gridX = _ref2[0],
        gridY = _ref2[1];

    return gridPoint(oDirection, oX, oY, size, gridX, gridY);
  });
};